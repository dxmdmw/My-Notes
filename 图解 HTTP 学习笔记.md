# 第 1 章  了解 Web 及网络基础
## 1.1 Web 基础

> 根据 Web 浏览器地址栏中指定的 URL，Web 浏览器从 Web 服务器端获取文件资源（resource）等信息，从而显示出 Web 页面。
> Web 使用一种名为 HPPT（HyperText Transfer Protocol，超文本传输协议）的协议作为规范，完成从客户端到服务器端等一系列运作流程。
> 3 项 WWW 构建技术，分别是：把 SGML（Standard Generalized Markup Language，标准通用标记语言）作为页面的文本标记语言的 HTML（HyperText Markup Language，超文本标记语言）；作为文档传递协议的 HTTP；指定文档所在地址的 URL（Uniform Resource Locator，统一资源定位符）。

## 1.3 网络基础 TCP/IP 

> TCP/IP 是互联网相关的各类协议族的总称。协议中存在各式各样的内容。从电缆的规格到 IP 地址的选定方法、寻找异地用户的方法、双方建立通信的顺序，以及 Web 页面显示需要处理的步骤，等等。
> TCP/IP 协议族按层次分为四层：应用层、传输层、网络层和数据链路层。
> 1. 应用层决定了向用户提供应用服务时通信的活动。比如 FTP（File Transfer Protocol，文件传输协议）和 DNS（Domain Name System，域名系统）服务就是其中两类。HPPT 协议也处于该层。
> 2. 传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。其中两个性质不同的协议：TCP（Transmission Control Protocol，传输控制协议）和 UDP（User Data Protocol，用户数据包协议）。
> 3. 网络层（又名网络互连层）用来处理在网络上流动的数据包（网络传输的最小数据单位）。该层规定了通过怎样的路径到达对方计算机，并把数据包传送给对方。
> 4. 链路层（又名数据链路层，网络接口层）用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在链路层的作用范围之内。

发送端在层与层之间传输数据时，每经过一层必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层会把对应的首部消去。这种把数据信息包装起来的做法称为封装（encapsulate）。

## 1.4 与 HTTP 关系密切的协议：IP、TCP 和 DNS
### 负责传输的 IP 协议
IP（Internet Protocol）网络协议位于网络层。IP 协议的作用是把各种数据包传送给对方，而要保证确实传送到对方那里，则需要满足各类条件。其中两个重要的条件是 IP 地址和 MAC 地址（Media Access Control Address）。
1. IP 地址指明了节点被分配到的地址，MAC 地址是指网卡所属的固定地址。两者可以配对，IP地址可变换，MAC 地址基本上不变。
2. 除了通信双方在同一局域网（LAN）的情况，通常是经过多台计算机和网络设备中转才能链接到对方。而中转时，会利用下一站中转设备的 MAC地址来搜索下一个中转目标。采用 ARP 协议（Address Resolution Protocol，用以解析地址的协议），根据通信方的 IP 地址就可以反查出对应的 MAC 地址。中转过程中，计算机和路由器等网络设备只能获悉很粗略的传输路线，这种机制称为路由选择（routing）。

### 确保可靠性的 TCP 协议
TCP 位于传输层，提供可靠的字节流服务（Byte Stream Service）。
> 字节流服务是指为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理。而可靠的传输服务是指通过三次握手策略（three-way handshaking）等手段能够把数据准确可靠地传给对方。
> 握手过程中使用了 TCP 的标志（flag）：SYN（synchronize）和 ACK（acknowledgement）。
> 发送端首先发送一个带 SYN 标志的数据包给对方，接收端收到后，回传一个带有 SYN/ACK 标志的数据包以示传达确认信息。最后发送端再回传一个带 ACK 标志的数据包，代表“握手”结束。若过程中某个阶段莫名中断，TCP 协议会再次以相同顺序发送相同的数据包。

### 负责域名解析的 DNS 服务
DNS（Domain Name System）服务适合 HTTP 协议一样位于应用层的协议。它提供域名到 IP 地址之间的解析服务。

## 1.7 URI 和 URL
1. URI（Uniform Resource Identifier，统一资源标识符），在 RFC2396中的定义：
* Uniform：规定统一的格式方便处理不同类型资源。另外加入新增的协议方案（如 http: 或 ftp:）也更容易
* Resource：“可标识的任何东西”。
* Identifier：表示可标识的对象。也成为标识符。
> 综上，URI 就是由某个协议方案表示的资源的定位标识符。URI 用字符串标识某一互联网资源，URL 表示资源的地点（互联网上所处的位置）。URL 是 URI 的子集。
2. URI 格式
表示指定的 URI，要使用涵盖全部必要信息的绝对 URI、绝对URL 以及相对 URL。
绝对 URI 的格式：协议方案名 + 登录信息（认证）（可选）+ 服务器地址 + 服务器端口号（可选）+ 带层次的文件路径+ 查询字符串（可选）+ 片段标识符（可选）
> 并不是所有的应用程序都符合 RFC。
> 有一些用来指定 HTTP 协议技术标准的文档，它们被称为 RFC（Request for Comments，征求修正意见书）。
> 通常，应用程序会遵照 RFC 标准，也有部分应用程序自成一套“标准”扩展的情况，作为例外存在。

# 第 2 章  简单的 HTTP 协议
## 2.1 HTTP 协议用于客户端和服务器端之间的通信
示例：
客户端发送请求报文，内容：
> GET /index.htm HTTP/1.1
> 
> Host: hackr.jp

起始行开头的 GET 表示请求访问服务器的类型，称为方法（method）。随后的字符串 /index.htm 指明了请求访问的资源对象，也叫作请求 URI（request-URI）。最后的 HTTP/1.1，即 HTTP 的版本号，用来提示客户端使用的 HTTP 协议功能。
综合来看，这段请求内容的意思是：请求访问某台 HTTP 服务器上的 /index.htm 页面资源。
请求报文是由请求方法、请求 URI、协议版本、可选的请求首部字段和内容实体构成的。

接收到请求的服务器，会将请求内容的处理结果以响应的形式返回。
> HTTP/1.1 200 OK
> 
> Date: Tue, 10 Jul 2012 06:50:15 GMT
> 
> Content-Length: 362
> 
> Content-Type: text/html
> 
> \<html>
> 
> ...

响应报文基本上由协议版本、状态码（status code）（表示请求成功或失败的数字代码）、用以解释状态码的原因短语（reason-phrase）、可选的响应首部字段（header field）以及实体主体（entity body）构成。

## 2.3 HTTP 是不保存状态的协议
HTTP 是一种不保存状态，即无状态（stateless）协议。HTTP 协议自身不对请求和响应之间的通信状态进行保存。也就是在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理。者是为了更快地处理大量事物，确保协议的可伸缩性。
随着 Web 的发展，保存用户状态的需求逐渐增多（比如网站中用户的登录状态），于是引入了 Cookie 技术管理状态。

## 2.4 请求 URI 定位资源
HTTP 协议使用 URI 定位互联网上的资源。当客户端请求访问资源而发送请求时，URI 需要将作为请求报文中的请求 URI 包含在内。指定请求 URI 的方式很多。
* URI 为完整的请求 URI
* 在首部字段 Host 中写明网络域名或 IP 地址
* 除此之外，如果不是访问特定资源而是对服务器本身发起请求，可以用一个 `*` 来代替请求 URI。下面这个例子是查询 HTTP 服务器端支持的 HTTP 方法种类。
> OPTIONS * HTTP/1.1

## 2.5 告知服务器意图的 HTTP 方法
HTTP/1.1中可使用的方法：
* GET：获取资源
  
  GET 方法用来请求访问已被 URI 识别的资源。指定的资源经服务器端解析后返回响应内容。
* POST：传输实体主体

  POST 方法用来传输实体的主体。
* PUT：传输文件

  PUT 方法用来传输文件。就像 FTP 协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求 URI 指定的位置。鉴于 HTTP/1.1的 PUT 方法自身不带验证机制导致的安全性问题，一般的 Web 网站不适用该方法。开发 PUT 方法的网站通常会配合 Web 应用程序的验证机制，或架构设计采用 REST（REpresentational State Transfer，表征状态转移）标准。
* HEAD：获得报文首部
  
  HEAD 方法和 GET 方法一样，只是不返回报文主体部分。用于确认 URI 的有效性及资源更新的日期时间等。
* DELETE：删除文件
  
  DELETE方法用来删除文件，是与 PUT 相反的方法。按请求 URI 删除指定的资源。安全性同 PUT方法。
* OPTIONS：询问支持的方法
  
  OPTIONS 方法用来查询针对请求 URI 指定的资源支持的方法。
* TRACE：追踪路径
  
  TRACE 方法是让 Web 服务器端将之前的请求通信环回给客户端的方法。但是不常用，且容易引发 XST（Cross-Site Tracing，跨站追踪）攻击。
* CONNECT：要求用隧道协议连接代理
  
  CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。主要使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。

## 2.7 持久连接节省通信量
HTTP协议的初始版本中，每进行一次 HTTP 通信就要断开一次 TCP 连接。增加了通信量开销。
为了解决上述问题，产生了 HTTP 持久连接（HTTP Persistent Connections，也称为 HTTP keep-alive 或 HTTP connection reuse）的方法。即默认保持 TCP 连接状态，除非任意一端明确提出断开连接。
* 管线化
  
  持久连接使得多数请求以管线化（pipelining）方式发送成为可能。能够支持同时并行发送多个请求，而不需要一个接一个地等待响应了。
## 2.8 使用 Cookie 的状态管理
为了保留 HTTP 无状态协议这个特征，又要解决管理客户端状态的矛盾问题。因此引入了 Cookie 技术。通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。
Cookie 会根据从服务器端发送的响应报文内的 Set-Cookie 首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送。
服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。

# 第 3 章  HTTP 报文内的 HTTP 信息
## 3.1 HTTP 报文
用于 HTTP 协议交互的信息被称为 HTTP 报文。它是由多行（用 CR+LF 作换行符）数据构成的字符串文本。由最初出现的空行（CR+LF）来划分为报文首部和报文主体（可选）两块。
## 3.3  编码提升传输速率
HTTP 在传输数据时可以按照数据原貌直接传输，也可以在传输过程中通过编码提升传输速率。后者能有效地处理大量访问请求，但是会消耗更多的 CPU 资源。
### 3.3.1 报文主体和实体主体的差异
* 报文（message）：是 HTTP 通信中的基本单位，由 8 位组字节流（octet sequence）组成，通过 HTTP 通信传输。
* 实体（entity）：作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成。

HTTP 报文的主体用于传输请求或响应的实体主体。通常报文主体等于实体主体。编码操作时，实体主体内容发生变化，与报文主题产生差异。

### 3.3.2 常见的内容编码方式
* gzip（GNU zip）
* compress（UNIX 系统的标准压缩）
* deflate（zlib）
* identity（不进行编码）

# 第 4 章  返回结果的 HTTP 状态码
## 4.1 状态码告知从服务器端返回的请求结果
状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。

状态码的类别：
||类别|原因短语|
|--|--|----|
|1XX|Informational（信息性状态码）|接受的请求正在处理|
|2XX|Success（成功状态码）|请求正常处理完毕|
|3XX|Redirection（重定向状态码）|需要进行附加操作以完成请求|
|4XX|Client Error（客户端错误状态码）|服务器无法处理请求|
|5XX|Server Error（服务器错误状态码）|服务器处理请求出错|

介绍常用且具有代表性的14个状态码
## 4.2 2XX 成功
### 4.2.1 200 OK 
表示从客户端发来的请求在服务器端被正常处理了。
在响应报文内，随状态码一起返回的信息会因方法的不同而发生改变。比如，使用 GET 方法时，对应请求资源的实体会作为响应返回；而是用 HEAD 方法时，对应请求资源的实体首部不随报文主体作为响应返回（即在响应中只返回首部，不会返回实体的主体部分）。
### 4.2.2 204 No Content 
代表服务器接受的请求已成功处理，但在返回的响应报文中不含实体的主体部分。另外也不允许返回任何实体的主体。用于不需要服务器发送新信息内容的情况。
### 4.2.3 206 Partial Content
表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。

## 4.3 3XX 重定向
### 4.3.1 301 Moved Permanently
永久性重定向。该状态码表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。即如果已经把资源对应的 URI 保存为书签了，这时应该按 Location 首部字段提示的 URI 重新保存。
### 4.3.2 302 Found
临时性重定向。与 301 相似，但是代表资源的移动是临时性质的。
### 4.3.3 303 See Other
表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。
### 4.3.4 304 Not Modified
表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。
304 状态码返回时，不包含任何响应的主体部分。虽然属于 3XX 类别，但和重定向没有关系。
> 附带条件的请求是指采用 GET 方法的请求报文中包含 If-Match，If-Modified——Since，If-None-Match，If-Range，If-Unmodified-Since 中任一首部。
### 4.3.5 307 Temporary Redirect
临时重定向。与 302 Found 含义相同。尽管 302 标准禁止 POST 变换成 GET，但实际使用时大家并不遵守。
307 会遵照浏览器标准，不会从 POST 变成 GET。但是对于处理响应时的行为，每种浏览器有可能出现不同的情况。
## 4.4 4XX 客户端错误
### 4.4.1 400 Bad Request
表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外浏览器会像 200 OK 一样对待该状态码。
### 4.4.2 401 Unauthorized
表示发送的请求需要有通过 HTTP认证（BASIC 认证、DIGEST 认证）的认证信息。另外若之前已进行过 1 次请求，则表示用户认证失败。
返回含有 401 的响应必须包含一个适用于被请求资源的 WWW-Authenticate 首部用以质询（challenge）用户信息。当浏览器初次接收到 401 响应，会弹出认证用的对话窗口。
### 4.4.3 403 Forbidden
表明对请求资源的访问被服务器拒绝了。如果服务器端想作说明，可以在实体的主体部分对原因进行描述，以此让用户看到。
未获得文件系统的访问授权，访问权限出现某些问题（从未授权的发送源 IP 地址试图访问）等列举的情况都可能是发生 403 的原因。
### 4.4.4 404 Not Found
表明服务器上无法找到请求的资源。也可以在服务器端拒绝请求且不想说明理由时使用。
## 4.5 5XX 服务器错误
### 4.5.1 500 Internal Server Error
表明服务器端在执行请求时发生了错误。也可能是 Web 应用存在的 bug 或某些临时的故障。
### 4.5.2 503 Service Unavailable
表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入 RetryAfter 首部字段再返回给客户端。
> 状态码和状况的不一致。
> 
> 不少返回的状态码响应都是错误的，但用户可能察觉不到。比如 Web 应用程序内部发生错误，状态码依然返回 200 OK。

# 第 5 章  与 HTTP 协作的 Web 服务器
一台 Web 服务器可搭建多个独立域名的 Web 网站，也可作为通信路径上的中转服务器提升传输效率。
## 5.1 用单台虚拟主机（Virtual Host，又称虚拟服务器）实现多个域名
客户端使用 HTTP 协议访问服务器时，经常采用主机名和域名的方式，通过 DNS 服务映射到 IP 地址（域名解析）之后访问目标网站。如果一台服务器内托管了两个域名，两者的访问 IP 地址会相同。因此在发送 HTTP 请求时，必须在 Host 首部内完整指定主机名或域名的 URI。

## 5.2 通信数据转发程序：代理、网关、隧道
### 5.2.1 代理
代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。
使用代理服务器的理由有：利用缓存技术减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的，等等。
代理有多种使用方法，按两种基准分类。一种是是否使用缓存，另一种是是否会修改报文。
* 缓存代理

  代理转发响应时，缓存代理（Caching Proxy）会预先将资源的副本（缓存）保存在代理服务器上。当代理再次接收到对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回。
* 透明代理

  转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理（Transparent Proxy）。反之，对报文内容进行加工的代理被称为非透明代理。
### 5.2.2 网关
网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。
网关的工作机制和代理十分相似。而网关能使通信线路上的服务器提供非 HTTP 协议服务。
利用网关能提高通信的安全性，因为可以在客户端和网关之间的通信线路上加密以确保连接的安全。比如，网关可以连接数据库，使用 SQL 语句查询数据。另外，在 Web 购物网站上进行信用卡结算时，网关可以和信用卡结算系统联动。
### 5.2.3 隧道
隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。
隧道可按要求建立起一条与其他服务器的通信线路，届时使用 SSL 等加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的通信。

## 5.3 保存资源的缓存
缓存是指代理服务器或客户端本地磁盘内保存的资源副本。可用来减少对源服务器的访问，节省通信流量和通信时间。
### 5.3.1 缓存的有效期限
由于客户端的要求、缓存的有效期等因素，缓存服务器会向源服务器确认资源的有效性。若失效，缓存服务器将会再次获取“新”资源。
### 5.3.2 客户端的缓存
缓存也可存在客户端浏览器中，以 Internet Explorer 程序为例，把客户端缓存称为临时网络文件（Temporary Internet File）。与服务器缓存类似。

# 第 6 章  HTTP 首部
HTTP 首部字段分为 4 种类型：通用首部字段，请求首部字段，响应首部字段，实体首部字段。

HTTP 首部字段将定义成缓存代理和非缓存代理的行为，分成 2 种类型。
* 端到端首部（End-to-end Header）

  分在此类别中的首部会转发给请求/响应对应的最终接收目标，且必须保存在由缓存生成的响应中，另外规定它必须被转发。
* 逐跳首部（Hop-by-hop Header）
  
  此类别中的首部只对单次转发有效，会因通过缓存或代理而不再转发。
  HTTP/1.1 中的逐跳首部字段仅 8 个：
  * Connection
  * Keep-Alive
  * Proxy-Authenticate
  * Proxy-Authorization
  * Trailer
  * TE
  * Transfer-Encoding
  * Upgrade

## 6.3 HTTP/1.1 通用首部字段
### 6.3.1 Cache-Contral
通过指定该首部字段，能操作缓存的工作机制
### 6.3.2 Connection
* 控制不再转发给代理的首部字段
  即 Hop-by-hop 首部
* 管理持久连接
  HTTP/1.1 版本的默认连接都是持久连接，为此客户端会在持久连接上持续发送请求。当服务器想明确断开连接时，则指定 Connection 首部字段的值为 Close。
### 6.3.3 Date
表明创建 HTTP 报文的日期和时间
### 6.3.4 Pragma
历史遗留字段之一，仅作为与 HTTP/1.0 的向后兼容而定义。
规范定义的形式唯一：
>Pragma: no-cache

属于通用首部字段，但只用在客户端发送的请求中。客户端会要求所有的中间服务器不返回缓存的资源。鉴于整体掌握全部中间服务器使用的 HTTP 版本是不现实的，因此发送的请求会同时包含：
>Cache-Control: no-cache  
>Pragma: no-cache
### 6.3.5 Trailer
事先说明在报文主体后记录了哪些首部字段。该首部字段可应用在 HTTP/1.1 版本分块传输编码时。
### 6.3.6 Transfer-Encoding
规定了传输报文主体时采用的编码方式
### 6.3.7 Upgrade
用于检测 HTTP 协议及其他协议是否可使用更高的版本进行通信，其参数值可以用来指定一个完全不同的通信协议。
### 6.3.8 Via
为了追踪客户端与服务器之间的请求和响应报文的传输路径。  
报文经过代理或网关时，会先在首部字段 Via中附加该服务器的信息，然后再进行转发。
### 6.3.9 Warning
告知用户一些与缓存相关的问题的警告
>Warning: [警告码][警告的主机：端口号]"[警告内容]"([日期时间])

## 6.4 请求首部字段
### 6.4.1 Accept
可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可使用 type/subtype 这种形式，一次指定多种媒体类型。
* 文本文件  
  text/html, text/plain, text/css ...
  application/xhtml+xml, application/xml
* 图片文件
  image/jpeg, image/gif, image/png ...
* 视频文件
  video/mpeg, video/quicktime ...
* 应用程序使用的二进制文件
  application/octet-stream, application/zip ...

若想要给显示的媒体类型增加优先级，则使用 q= 来额外表示权重值，用分号进行分割。默认权重 q=1.0，范围 0-1（可精确到小数点后 3 位）。服务器会首先返回权重值最高的媒体类型。
### 6.4.2 Accept-Charset
通知服务器用户代理支持的字符集及字符集的相对优先顺序。可一次性指定多种字符集，用权重 q 表示相对优先级。  
该首部字段应用于内容协商机制的服务器驱动协商。
### 6.4.3 Accept-Encoding
告知服务器用户代理支持的内容编码以及内容编码的优先级顺序。可一次性指定多种内容编码。权重值区分优先级。
### 6.4.4 Accept-Language
告知服务器用户代理能够处理的自然语言集，以及相对优先级。
### 6.4.5 Authorization
告知服务器，用户代理的认证信息（证书值）。通常，想要通过服务器认证的用户代理会在接收到返回的 401 状态码响应后，把首部字段 Authorization 加入请求中。共用缓存在接收到含有 Authorization 首部字段的请求时的操作处理会略有差异。
### 6.4.6 Expect
告知服务器，期望出现的某种特定行为。因服务器无法理解客户端的期望作出回应而发生错误时，会返回状态码 417 Expectation Failed。  
客户端可以利用该首部字段，写明所期望的扩展。HTTP/1.1 规范之定义了 100-continue（状态码 100 Continue 之意）。  
等待状态码 100 响应的客户端在发生请求时，需要制定 Expect:100-continue。
### 6.4.7 From
告知服务器使用用户代理的用户的电子邮件地址。
### 6.4.8 Host
告知服务器，请求的资源所处的互联网主机名和端口号。是 HTTP/1.1 规范内唯一一个必须被包含在请求内的首部字段。和以单台服务器分配多个域名的虚拟主机的工作机制有很密切的关联。
若服务器未设定主机名，直接发送一个空值 `Host:` 即可。
### 6.4.9 If-Match
属于条件请求。服务器需要判断指定条件为真，才执行请求。
告知服务器匹配资源所用的实体标记（ETag）值。可以用星号 `*` 指定忽略。
### 6.4.10 If-Modified-Since
告知服务器若 If-Modified-Since 字段值早于资源的更新时间，则希望能处理该请求。否则返回状态码 304 Not Modified 的响应。
### 6.4.11 If-None-Match
和 If-Match 作用相反。用于指定 If-None-Match 字段值的实体标记（ETag）值与请求资源的 ETag 值不一致时，它就告知服务器处理该请求。  
在 GET 或 HEAD 方法中使用首部字段 If-None-Match 可获取最新的资源。类似于 If-Modified-Since。
### 6.4.12 If-Range
告知服务器若指定的 If-Range 字段值（ETag 值或者时间）和请求资源的 ETag 值或时间相一致时，则作为范围请求处理。反之，则返回全体资源。
### 6.4.13 If-Unmodified-Since
与 If-Modified-Since 作用相反。告知服务器，指定的请求资源只有在字段值内指定的日期时间之后，未发生更新的情况下，才能处理请求。否则以状态码 412 Precondition Failed 作为响应返回。
### 6.4.14 Max-Forwards
通过 TRACE 方法或 OPTIONS 方法，发送包含首部字段 Max-Forwards 的请求时，该字段以十进制整数形式指定可经过的服务器最大数目。经过一次代理服务器转发时，数值减 1。当服务器接收到值为 0 的请求时，则不再进行转发，直接返回响应。  
可用来测试确认某台代理服务器之前的传输路径状况。
### 6.4.15 Proxy-Authorization
接收到从代理服务器发来的认证质询时，客户端会发送包含首部字段 Proxy-Authorization的请求，以告知服务器认证所需要的信息。  
该认证行为发生在客户端与代理之间。客户端与服务器之间的认证，使用首部字段 Authorization可起到相同作用。
### 6.4.16 Range
只获取部分资源的范围请求。  
接收到该请求的服务器，会在处理请求之后返回状态码 206 Partial Content 的响应。无法处理该范围请求时，则会返回状态码 200 OK 的响应及全部资源。
### 6.4.17 Referer
告知服务器请求的原始资源的 URI。  
### 6.4.18 TE
告知服务器客户端能够处理响应的传输编码方式以及相对优先级。类似于 Accept-Encoding ，但是用于传输编码。
### 6.4.19 User-Agent
将创建请求的浏览器和用户代理名称等信息传达给服务器。  
由网络爬虫发起请求时，有可能会在字段内添加爬虫作者的电子邮件地址。此外，如果请求经过代理，那么中间也很可能被添加上代理服务器的名称。
## 6.5 响应首部字段
### 6.5.1 Accept-Ranges
告知客户端服务器是否能处理范围请求，以指定获取服务器端某个部分的资源。  
可指定的字段值有两种，可处理范围请求时指定其为 bytes，反之则指定其为 none。
### 6.5.2 Age
告知客户端，源服务器在多久前创建了响应。单位为秒。  
若创建该响应的服务器是缓存服务器，Age 值是指缓存后的响应再次发起认证到认证完成的时间值。代理创建响应时必须加上首部字段 Age。
### 6.5.3 ETag
告知客户端实体标识。是一种可将资源以字符串形式做唯一性标识的方式。资源更新时，ETag 值也需要更新，由服务器来分配 ETag值。  
* 强 ETag 值
  不论实体发生多么细微的变化都会改变其值。
  > ETag: "usagi-1234"
* 弱 ETag 值
  只用于提示资源是否相同。只有资源发生了根本改变，产生差异时才会改变 ETag 值。这时，会在字段值最开始处附加 W/。
  > ETag: W/"usagi-1234"
### 6.5.4 Location
将响应接收方引导至某个与请求 URI 位置不同的资源。  
基本上，该字段会配合 3xx：Redirection 的响应，提供重定向的 URI。  
### 6.5.5 Proxy-Authenticate
把由代理服务器所要求的认证信息发送给客户端。  
### 6.5.6 Retry-After
告知客户端应该在多久之后再次发送请求。
### 6.5.7 Server
告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息。包括软件应用名称，版本号，和安装时启用的可选项。
### 6.5.8 Vary
对缓存进行控制。源服务器会向代理服务器传达关于本地缓存使用方法的命令。  
从代理服务器接收到源服务器返回包含 Vary 指定项的相应之后，若再要进行缓存，仅对请求中含有相同 Vary 指定首部字段的请求返回缓存。否则必须要从源服务器重新获取资源。
### 6.5.9 WWW-Authenticate
用于 HTTP 访问认证。告知客户端适用于访问请求 URI 所指定资源的认证方案（Basic 或是 Digest）和带参数提示的质询。状态码 401 Unauthorized 响应中，肯定带有此首部。
## 6.6 实体首部字段
实体首部字段是包含在请求报文和响应报文中的实体部分所使用的首部，用于补充内容的更新时间等与实体相关的信息。
### 6.6.1 Allow
用于通知客户端能够支持 Request-URI 指定资源的所有 HTTP 方法。
### 6.6.2 Content-Encoding
告知客户端服务器对实体的主体部分选用的内容编码方式。
### 6.6.3 Content-Language
告知客户端，实体主体使用的自然语言。
### 6.6.4 Content-Length
表明了实体主体部分的大小（单位是字节）。
### 6.6.5 Content-Location
给出于报文主体部分相对应的 URI。和首部字段 Location 不同，Content-Location 表示的是报文主体返回资源对应的 URI。
### 6.6.6 Content-MD5
是一串由 MD5 算法生成的值，目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达。  
### 6.6.7 Content-Range
针对范围请求，返回响应时使用的首部字段。能告知客户端作为响应返回的实体的哪个部分符合范围请求。字段值以字节为单位，表示当前发送部分及整个实体大小。
### 6.6.8 Content-Type
说明了实体主体内对象的媒体类型。
### 6.6.9 Expires
将资源失效的日期告知客户端。
### 6.6.10 Last-Modified
指明资源最终修改的时间。
## 6.7 为 Cookie 服务的首部字段
管理服务器与客户端之间状态的 Cookie，虽然没有被编入标准化 HTTP/1.1 的 RFC2616 中，但在 Web 网站方面得到了广泛的应用。  
Cookie 的工作机制是用户识别及状态管理。Web 网站为了管理用户的状态会通过 Web 浏览器，把一些数据临时写入用户的计算机内。接着当用户访问该 Web 网站时，可通过通信方式取回之前发放的 Cookie。  
调用 Cookie 时，由于可校验 Cookie 的有效期，以及发送方的域、路径、协议等信息，所以正规发布的 Cookie 内的数据不会因来自其它 Web 站点和攻击者的攻击而泄露。  
目前最为普及的 Cookie 方式是以网景公司制定的相关规格标准为基准的。  
### 6.7.1 Set-Cookie
当服务器准备开始管理客户端的状态时，会事先告知各种信息。  
下面的表格列举了 Set-Cookie 的字段值。
|属性|说明|
|--|--|
|NAME=VALUE|赋予 Cookie 的名称和其值（必须项）|
|expires=DATE|Cookie 的有效期（若不明确指定则默认为浏览器关闭前为止）|
|path=PATH|将服务器上的文件目录作为 Cookie 的适用对象（若不指定则默认为文档所在的文件目录）|
|domain=域名|作为 Cookie 适用对象的域名（若不指定则默认为创建 Cookie 的服务器的域名）|
|Secure|仅在 HTTPS 安全通信时才会发送 Cookie|
|HttpOnly|加以限制，使 Cookie 不能被 JavaScript 脚本访问|
**expires** 属性
指定浏览器可发送 Cookie 的有效期。
**path** 属性
用于限制指定 Cookie 的发送范围的文件目录。
**domain** 属性
指定的域名可做到与结尾匹配一致。比如，当指定 example.com 后，除此之外，www.example.com 或 www2.example.com 等都可以发送 Cookie。  
因此，不指定 domain 属性显得更安全。
**secure** 属性
用于限制 Web 页面仅在 HTTPS 安全连接时，才可以发送 Cookie。
**HttpOnly** 属性
Cookie 的扩展功能，它使 JavaScript 脚本无法获得 Cookie。其主要目的为防止跨站脚本攻击（Cross-site scripting，XSS）对 Cookie 的信息窃取。  
> Set-Cookie: name=value; HttpOnly  

通过上述设置，通常从 Web 页面内还可以对 Cookie 进行读取操作。但使用 JavaScript 的 document.cookie 就无法读取附加 HttpOnly 属性后的 Cookie 的内容了。也就无法在 XSS 中利用 JavaScript 劫持 Cookie 了。
### 6.7.2 Cookie
> Cookie: status=enable

告知服务器，当客户端想获得 HTTP 状态管理支持时，就会在请求中包含从服务器接收到的 Cookie。
## 6.8 其他首部字段
### 6.8.1 X-Frame-Options
属于 HTTP 响应首部，用户控制网站内容在其他 Web 网站的 Frame 标签内的显示问题。其主要目的是为了防止点击劫持（clickjacking）攻击。  
有以下两个可指定的字段值。
* DENY：拒绝
* SAMEORIGIN：仅同源域名下的页面（Top-level-browsing-context）匹配时许可。

对 apache2.conf 的配置实例
```sh
<IfModule mod_headers.c>
    Header append X-FRAME-OPTIONS "SAMEORIGIN"
</IfModule>
```
### 6.8.2 X-XSS-Protection
属于 HTTP 响应首部，是针对跨站脚本攻击（XSS）的一种对策，用于控制浏览器 XSS 防护机制的开关。  
可指定的字段值如下。
* 0：将 XSS 过滤设置成无效状态  
* 1：将 XSS 过滤设置成有效状态
### 6.8.3 DNT
属于 HTTP 请求首部，Do Not Track 的简称，意为拒绝个人信息被收集，是表示拒绝被精准广告追踪的一种方法。  
可指定的字段值如下。
* 0：同意被追踪
* 1：拒绝被追踪
### 6.8.4 P3P
属于 HTTP 响应首部，通过利用 P3P（The Platform for Privacy Preferences，在线隐私偏好平台）技术，可以让 Web 网站上的个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私的目的。  
有关 P3P 的详细规范标准请参看下方链接。  
https://www.w3.org/TR/P3P/

# 第 7 章 确保 Web 安全的 HTTPS
## 7.1 HTTP 的缺点
### 7.1.1 通信使用明文可能会被窃听
* TCP/IP 是可能被窃听的网络
* 加密处理防止被窃听
  最普及的防止窃听保护信息对策是加密技术。
  1. 通信的加密
     HTTP 协议中没有加密机制，但可以通过和 SSL（Secure Socket Layer，安全套接层）或 TLS（Transport Layer Security，安全层传输协议）的组合使用，加密 HTTP 的通信内容。
     用 SSL 建立安全通信线路之后，就可以在这条线路上进行 HTTP 通信了。与 SSL 组合使用的 HTTP 被称为 HTTPS（HTTP Secure，超文本传输安全协议）或 HTTP over SSL。
  2. 内容的加密
     将参与通信的内容本身加密。前提是要求客户端和服务器同时具备加密和解密机制。主要应用在 Web 服务中。由于该方式不同于 SSL 或 TLS 将整个通信线路加密处理，所以内容仍有被篡改的风险。
### 7.1.2 不验证通信方的身份就可能遭遇伪装
* HTTP 无法确定伪装和 DoS 攻击（Denial of Service，拒绝服务攻击）。
* SSL 不仅提供加密处理，还使用了“证书”（由值得信任的第三方机构颁发）手段，可用于确定方。
### 7.1.3 无法证明报文完整性，可能已遭篡改
请求或响应在传输途中，遭攻击者拦截并篡改内容的供给称为中间人攻击（Man-in-the-Middle attack，MITM）。  
使用 HTTP 协议确定报文完整性的方法，比如 MD5 和 SHA-1 等散列值校验的方法以及用来确认文件的数字签名方法，事实上并不便捷、可靠。  
因为其本身被改写，就无法用来判断。因此有必要使用 HTTPS。
## 7.2 HTTP + 加密 + 认证 + 完整性保护 = HTTPS
# 7.2.1 HTTP 加上加密处理和认证以及完整性保护后即是 HTTPS
# 7.2.2 HTTPS 是身披 SSL 外壳的 HTTP
HTTPS 是 HTTP 通信接口部分用 SSL 和 TLS 协议代替。  
通常 HTTP 直接和 TCP 通信，但是用 SSL 时，则先和 SSL 通信，再由 SSL 和 TCP 通信。  
SSL 是独立于 HTTP 的协议，其他运行在应用层的 SMTP 和 Telnet 等协议均可配合 SSL 协议使用。它是当今世界上应用最为广泛的网络安全技术。
### 7.2.3 相互交换密钥的公开密钥加密技术
HTTPS 采用混合加密机制，即在交换密钥环节使用公开密钥加密方式（安全），之后的建立通信交换报文阶段则使用共享密钥加密方式（快）。
### 7.2.4 证明公开密钥正确性的证书
公开密钥加密方式无法证明公开密钥就是货真价实的公开密钥。有可能传输途中已经被攻击者替换掉了公开密钥。  
为此可以使用由数字证书认证机构（CA，Certificate Authority）和其相关机关颁发的公开密钥证书。  
数字证书认证机构在判明提出申请者（服务器运营人员）身份后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将其放入公钥证书后绑定在一起。  
服务器会将这份证书发送给客户端，已进行公开密钥加密方式通信。  
客户端可使用数字证书认证机构的公开密钥，对证书上的数字签名进行验证，以信任该服务器的公开密钥是经过可信认证的。  
多数浏览器开发商发布版本时，会是现在内部植入常用认证机关的公开密钥。
### 7.2.5 HTTPS 的安全通信机制
1. 客户端通过发送 Client Hello 报文开始 SSL 通信。报文中包含客户端支持的 SSL 的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。
2. 服务器可进行 SSL 通信时，会以 Server Hello 报文作为应答。和客户端一样，在报文中包含 SSL 版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。
3. 之后服务器发送 Certificate 报文。报文中包含公开密钥证书。
4. 最后服务器发送 Server Hello Done 报文通知客户端，最初阶段的 SSL 握手协商部分结束。
5. SSL 第一次握手结束之后，客户端以 Client Key Exchange 报文作为回应。报文中包含通信加密中使用的一种被称为 Pre-master secret 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密。
6. 接着客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器，在此报文之后的通信会采用 Pre-master secret 密钥加密。
7. 客户端发送 Finished 报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。
8. 服务器同样发送 Change Cipher Spec 报文。
9. 服务器同样发送 Finished 报文。
10. 服务器和客户端的 Finished 报文交换完毕之后，SSL连接就算建立完成。当然，通信会受到 SSL 的保护。从此处开始进行应用层协议的通信，即发送 HTTP 请求。
11. 应用层协议通信，即发送 HTTP 响应。
12. 最后由客户端断开连接。断开连接时，发送 close_notify 报文。之后再发送 TCP FIN 报文来关闭与 TCP 的通信。  

在以上流程中，应用层发送数据时会附加一种叫做 MAC（Message Authentication Code）的报文摘要。能够查知报文是否遭到篡改，从而保护报文的完整性。
